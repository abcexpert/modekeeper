#!/usr/bin/env python3
from __future__ import annotations

import argparse
import re
from collections import Counter, defaultdict
from dataclasses import dataclass
from pathlib import Path


@dataclass(frozen=True)
class Ticket:
    ticket_id: str
    title: str
    status: str


ID_RE = re.compile(r"^\s*-\s*ID:\s*(\S+)\s*$")
TITLE_RE = re.compile(r"^\s*Title:\s*(.+?)\s*$")
STATUS_RE = re.compile(r"^\s*Status:\s*(.+?)\s*$")


def parse_tickets(path: Path) -> list[Ticket]:
    lines = path.read_text(encoding="utf-8").splitlines()
    blocks: list[list[str]] = []
    current: list[str] = []
    for line in lines:
        if ID_RE.match(line):
            if current:
                blocks.append(current)
            current = [line]
            continue
        if current:
            current.append(line)
    if current:
        blocks.append(current)

    tickets: list[Ticket] = []
    for block in blocks:
        ticket_id = ""
        title = ""
        status = ""
        for line in block:
            if not ticket_id:
                m_id = ID_RE.match(line)
                if m_id:
                    ticket_id = m_id.group(1).strip()
                    continue
            if not title:
                m_title = TITLE_RE.match(line)
                if m_title:
                    title = m_title.group(1).strip()
                    continue
            if not status:
                m_status = STATUS_RE.match(line)
                if m_status:
                    status = m_status.group(1).strip().upper()
                    continue
        if not ticket_id:
            continue
        if not title:
            title = "(missing title)"
        if not status:
            status = "UNKNOWN"
        tickets.append(Ticket(ticket_id=ticket_id, title=title, status=status))
    return tickets


def id_sort_key(ticket_id: str) -> tuple[str, int, str]:
    m = re.fullmatch(r"([A-Za-z]+)-(\d+)", ticket_id)
    if not m:
        return (ticket_id, 0, ticket_id)
    return (m.group(1), int(m.group(2)), ticket_id)


def status_sort_key(status: str) -> tuple[int, str]:
    if status == "DONE":
        return (0, status)
    return (1, status)


def status_bucket_for_step(title: str) -> tuple[int, str]:
    t = title.lower()
    trust_words = ("customer", "quickstart", "pypi", "release", "onboarding", "distribution")
    safety_words = ("safety", "kill-switch", "verify", "license", "rbac", "guard")
    governance_words = ("governance", "approval", "fleet", "policy", "audit", "compliance")
    proof_words = ("roi", "report", "evidence", "eval", "playbook", "demo", "export", "bundle")
    if any(w in t for w in trust_words):
        return (0, "Buyer-facing trust")
    if any(w in t for w in safety_words):
        return (1, "Safety")
    if any(w in t for w in governance_words):
        return (2, "Governance")
    if any(w in t for w in proof_words):
        return (3, "Proof artifacts")
    return (4, "General readiness")


def value_statement(title: str) -> str:
    t = title.lower()
    if any(w in t for w in ("release", "pypi", "distribution", "packaging")):
        return "Reduces distribution risk for enterprise procurement."
    if any(w in t for w in ("kill-switch", "safety", "verify", "rbac", "license")):
        return "Strengthens safety and control gates before any mutation."
    if any(w in t for w in ("governance", "fleet", "approval", "audit", "policy")):
        return "Improves governance and change-control posture."
    if any(w in t for w in ("roi", "value", "report", "evidence", "eval", "export")):
        return "Provides buyer-facing proof of value and outcomes."
    if any(w in t for w in ("quickstart", "onboarding", "doctor")):
        return "Shortens time-to-first-value for customer teams."
    return "Improves enterprise pilot readiness."


def render_status(tickets: list[Ticket], source: Path) -> str:
    total = len(tickets)
    counts = Counter(t.status for t in tickets)
    done = sorted((t for t in tickets if t.status == "DONE"), key=lambda t: id_sort_key(t.ticket_id), reverse=True)
    open_by_status: dict[str, list[Ticket]] = defaultdict(list)
    for t in tickets:
        if t.status != "DONE":
            open_by_status[t.status].append(t)
    for status in open_by_status:
        open_by_status[status].sort(key=lambda t: id_sort_key(t.ticket_id))

    open_tickets = sorted((t for t in tickets if t.status != "DONE"), key=lambda t: id_sort_key(t.ticket_id))
    prioritized_open = sorted(open_tickets, key=lambda t: (status_bucket_for_step(t.title), id_sort_key(t.ticket_id)))

    lines: list[str] = []
    lines.append("# ModeKeeper Status")
    lines.append("")
    lines.append("_Generated by `bin/mk-status`._")
    lines.append(f"_Source: `{source.as_posix()}`_")
    lines.append("")
    lines.append("## Totals By Status")
    lines.append(f"- TOTAL: {total}")
    for status in sorted(counts.keys(), key=status_sort_key):
        lines.append(f"- {status}: {counts[status]}")

    lines.append("")
    lines.append("## Completed Highlights")
    if done:
        for ticket in done[:10]:
            lines.append(f"- {ticket.ticket_id} — {ticket.title} — {value_statement(ticket.title)}")
    else:
        lines.append("- None.")

    lines.append("")
    lines.append("## Remaining Work")
    if open_by_status:
        for status in sorted(open_by_status.keys()):
            lines.append(f"### {status} ({len(open_by_status[status])})")
            for ticket in open_by_status[status]:
                lines.append(f"- {ticket.ticket_id} — {ticket.title}")
            lines.append("")
        if lines and lines[-1] == "":
            lines.pop()
    else:
        lines.append("- None (all tickets are currently DONE).")

    lines.append("")
    lines.append("## Next 3 Steps")
    if prioritized_open:
        for idx, ticket in enumerate(prioritized_open[:3], start=1):
            bucket = status_bucket_for_step(ticket.title)[1]
            lines.append(f"{idx}. [{bucket}] {ticket.ticket_id} — {ticket.title}")
    else:
        lines.append("1. [Buyer-facing trust] Refresh customer-safe quickstart evidence and keep links current for active deals.")
        lines.append("2. [Safety] Re-run kill-switch, license, and verify-gate proof runs and publish dated artifacts.")
        lines.append("3. [Governance/Proof artifacts] Package latest policy/governance and ROI bundle for procurement and security review.")

    lines.append("")
    return "\n".join(lines)


def main() -> int:
    parser = argparse.ArgumentParser(description="Regenerate docs/STATUS.md from docs/TICKETS.md.")
    parser.add_argument(
        "--tickets",
        default="docs/TICKETS.md",
        help="Path to TICKETS markdown source (default: docs/TICKETS.md)",
    )
    parser.add_argument(
        "--out",
        default="docs/STATUS.md",
        help="Path to output markdown file (default: docs/STATUS.md)",
    )
    args = parser.parse_args()

    tickets_path = Path(args.tickets)
    out_path = Path(args.out)
    tickets = parse_tickets(tickets_path)
    rendered = render_status(tickets, tickets_path)
    out_path.write_text(rendered, encoding="utf-8")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
