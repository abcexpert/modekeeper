#!/usr/bin/env python3
"""Generate an Ed25519 issuer keypair and a keyring entry."""

from __future__ import annotations

import argparse
import base64
import json
import os
import sys
from pathlib import Path


def _repo_root() -> Path:
    return Path(__file__).resolve().parent.parent


def _ensure_venv_and_imports(repo: Path) -> None:
    venv_py = (repo / ".venv/bin/python").resolve()
    cur_py = Path(sys.executable).resolve()
    if venv_py.exists() and cur_py != venv_py:
        os.execv(str(venv_py), [str(venv_py), str(__file__), *sys.argv[1:]])

    src = (repo / "src").resolve()
    if src.exists() and str(src) not in sys.path:
        sys.path.insert(0, str(src))


def _load_keyring(path: Path) -> dict[str, str]:
    if not path.exists():
        return {}
    payload = json.loads(path.read_text(encoding="utf-8"))
    if not isinstance(payload, dict):
        raise ValueError(f"keyring is not a JSON object: {path}")
    for kid, key in payload.items():
        if not isinstance(kid, str) or not isinstance(key, str):
            raise ValueError(f"keyring must be map[str, str]: {path}")
    return dict(payload)


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Generate issuer private key and keyring entry.")
    parser.add_argument("--kid", required=True, help="Key identifier.")
    parser.add_argument("--out-priv", required=True, help="Output path for raw 32-byte private key.")
    parser.add_argument("--out-keyring", required=True, help="Output path for keyring JSON map.")
    parser.add_argument(
        "--merge-keyring",
        help="Optional existing keyring path to merge, preserving other kids.",
    )
    return parser.parse_args()


def main() -> int:
    repo = _repo_root()
    _ensure_venv_and_imports(repo)
    args = _parse_args()

    kid = args.kid.strip()
    if not kid:
        raise SystemExit("--kid must be non-empty")

    out_priv = Path(args.out_priv)
    out_keyring = Path(args.out_keyring)
    merge_keyring = Path(args.merge_keyring) if args.merge_keyring else None

    from cryptography.hazmat.primitives import serialization
    from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey

    private_key = Ed25519PrivateKey.generate()
    private_raw = private_key.private_bytes(
        encoding=serialization.Encoding.Raw,
        format=serialization.PrivateFormat.Raw,
        encryption_algorithm=serialization.NoEncryption(),
    )
    public_raw = private_key.public_key().public_bytes(
        encoding=serialization.Encoding.Raw,
        format=serialization.PublicFormat.Raw,
    )
    public_b64 = base64.b64encode(public_raw).decode("ascii")

    merged = _load_keyring(merge_keyring) if merge_keyring is not None else {}
    merged[kid] = public_b64

    out_priv.parent.mkdir(parents=True, exist_ok=True)
    out_keyring.parent.mkdir(parents=True, exist_ok=True)
    out_priv.write_bytes(private_raw)
    os.chmod(out_priv, 0o600)
    out_keyring.write_text(
        json.dumps(merged, indent=2, sort_keys=True, ensure_ascii=False) + "\n",
        encoding="utf-8",
    )
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
